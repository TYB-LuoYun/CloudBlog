import{_ as e,o as a,c as r,a as d}from"./app-f942c568.js";const i={},n=d('<h2 id="防重幂等性问题-如何防止抖动-重复下订单" tabindex="-1"><a class="header-anchor" href="#防重幂等性问题-如何防止抖动-重复下订单" aria-hidden="true">#</a> 防重幂等性问题 ---如何防止抖动，重复下订单</h2><p>重复提交原因 其实原因无外乎两种：</p><p>一种是由于用户在短时间内多次点击下单按钮，或浏览器刷新按钮导致。 另一种则是由于Nginx或类似于SpringCloud Gateway的网关层，进行超时重试造成的。</p><p>Order 服务调用 Pay 服务，刚好网络超时，然后 Order 服务开始重试机制，于是 Pay 服务对同一支付请求，就接收到了两次，而且因为轮询负载均衡算法，落在了不同业务节点！所以一个分布式系统接口，须保证幂等性。</p><p>幂等性要做到: 1每个请求须有唯一标识 2每次处理完请求后，须有记录标识该请求已被处理 3每次接收请求时，判断之前是否处理过</p><p>解决: 1提交订单按钮置灰 2预生成全局唯一订单号,利用数据库的唯一索引特性，在插入订单记录时，如果该“全局唯一的订单号”重复，记录会插入失败 3将一些重要的参数比如用户id，商品id，价格，数量 进行md5 或者 拼接 作为 分布式锁的 键</p><h2 id="redis或mongdb存缓存与存库的一致性问题" tabindex="-1"><a class="header-anchor" href="#redis或mongdb存缓存与存库的一致性问题" aria-hidden="true">#</a> redis或mongdb存缓存与存库的一致性问题</h2><p>先更新数据库，再更新缓存，加事务，整个方法执行完成后再提交</p><h2 id="防止库存超卖" tabindex="-1"><a class="header-anchor" href="#防止库存超卖" aria-hidden="true">#</a> 防⽌库存超卖</h2><p>数据库锁：select xxx for update；悲观锁，在事务提交之前，其他事务可以读取被锁定的行，但不能修改或删除这些行 分布式锁: 可以阻塞等待一段时间，再报错 乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失败。</p><p>总结：</p><p>总的来说，不能把压⼒放在数据库上，所以使⽤ “select xxx for update” 的⽅式在⾼并发的场景下是不可⾏的。FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤。所以相对来说，我会倾向于选择：乐观锁 / 缓存锁 / 分布式锁的⽅式。</p><h2 id="aba-问题" tabindex="-1"><a class="header-anchor" href="#aba-问题" aria-hidden="true">#</a> ABA 问题</h2><p>业务: 一个请求修改A，修改成功但是没有响应，此时用户发起了另一个请求修改成B ，但是上一个请求会重试 又会修改A 解决方案: 查询更新时候带版本号，更新成功后版本号加1(UPDATE orders set tracking_number = 666, version = version + 1 WHERE version = 8;) 线程: 线程1读取共享变量值A，并执行一些计算，然后线程2将该共享变量的值更改为B，最后线程2又将其值改回A, 在CAS操作中，它检查共享变量的值是否与预期的值A相同，结果是相同的，所以线程1错误地认为没有其他线程修改过这个值，并执行更新操作</p><p>避免ABA问题的解决方案： 版本号或时间戳：对数据进行版本控制或标记时间戳 原子引用：使用原子引用类（AtomicReference等）来保证原子性操作</p>',15),t=[n];function s(o,c){return a(),r("div",null,t)}const p=e(i,[["render",s],["__file","yewuwenti.html.vue"]]);export{p as default};
