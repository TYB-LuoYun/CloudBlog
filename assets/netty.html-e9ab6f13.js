import{_ as e,o as t,c as a,a as r}from"./app-187dd937.js";const n="/assets/image-20240524144430288-b15d1ba9.png",c={},o=r('<h1 id="八股文" tabindex="-1"><a class="header-anchor" href="#八股文" aria-hidden="true">#</a> 八股文</h1><h3 id="netty的线程模型" tabindex="-1"><a class="header-anchor" href="#netty的线程模型" aria-hidden="true">#</a> netty的线程模型？</h3><p>netty的线程模型就是经典的reactor模型，底层基于io多路复用（select，poll，epoll三种实现）。reactor模型又分为单线程，多线程，主从reactor。这个去看看具体描述。这几种模式在netty中都有可能会出现，主要看你代码怎么配置。</p><p><img src="'+n+'" alt="image-20240524144430288"></p><p>我们通常的使用姿势，是用主从reactor模型，用单独的主reactor线程来处理连接的事件，用从reactor线程来处理io读写事件，来达到极致的性能。</p><h3 id="netty为什么用堆外内存" tabindex="-1"><a class="header-anchor" href="#netty为什么用堆外内存" aria-hidden="true">#</a> <strong>netty为什么用堆外内存？</strong></h3><p>java实现堆外内存的方法，可以用DirectByteBuffer来实现，它会申请一个堆外内存。堆外内存不由jvm管理，不会进行垃圾回收，同样在数据传输的时候，不需要经过用户态》内核态》网卡的步骤，内核态和用户态都指向这片内存空间，减少拷贝次数。 优点： 1不参与垃圾回收，不会占用每次垃圾回收器的扫描，清理时间。 2减少用户态到内核态的拷贝，提升效率。 缺点： 1堆外内存比较难控制和管理，产生内存泄漏很难排查到。</p>',7),s=[o];function i(d,h){return t(),a("div",null,s)}const _=e(c,[["render",i],["__file","netty.html.vue"]]);export{_ as default};
