import{_ as e,o as a,c as r,e as t}from"./app-70d92285.js";const d={},c=t('<h2 id="防重幂等性问题-如何防止抖动-重复下订单" tabindex="-1"><a class="header-anchor" href="#防重幂等性问题-如何防止抖动-重复下订单" aria-hidden="true">#</a> 防重幂等性问题 ---如何防止抖动，重复下订单</h2><h2 id="redis或mongdb存缓存与存库的一致性问题" tabindex="-1"><a class="header-anchor" href="#redis或mongdb存缓存与存库的一致性问题" aria-hidden="true">#</a> redis或mongdb存缓存与存库的一致性问题</h2><p>先更新数据库，再更新缓存，加事务，整个方法执行完成后再提交</p><h2 id="防止库存超卖" tabindex="-1"><a class="header-anchor" href="#防止库存超卖" aria-hidden="true">#</a> 防⽌库存超卖</h2><p>悲观锁：在更新库存期间加锁，不允许其它线程修改；</p><p>数据库锁：select xxx for update；</p><p>分布式锁；</p><p>乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失败。</p><p>redis watch：监视键值对，作⽤时如果事务提交exec时发现监视的监视对发⽣变化，事务将被取消。</p><p>消息队列：通过 FIFO 队列，使修改库存的操作串⾏化。</p><p>总结：</p><p>总的来说，不能把压⼒放在数据库上，所以使⽤ “select xxx for update” 的⽅式在⾼并发的场景下是不可⾏的。FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤。所以相对来说，我会倾向于选择：乐观锁 / 缓存锁 / 分布式锁的⽅式。</p>',12),n=[c];function i(s,h){return a(),r("div",null,n)}const p=e(d,[["render",i],["__file","yewuwenti.html.vue"]]);export{p as default};
