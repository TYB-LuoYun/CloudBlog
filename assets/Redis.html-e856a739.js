import{_ as e,o as a,c as r,a as i}from"./app-187dd937.js";const d={},s=i('<h1 id="八股文" tabindex="-1"><a class="header-anchor" href="#八股文" aria-hidden="true">#</a> 八股文</h1><h2 id="redis-数据类型" tabindex="-1"><a class="header-anchor" href="#redis-数据类型" aria-hidden="true">#</a> Redis 数据类型</h2><p>常用 String:存储缓存信息 List: Hash: Set: 无序唯一的键值类型; Sorted Set： 有序集合，比Set多了个score分值。场景:排行榜</p><h2 id="缓存穿透-雪崩-击穿" tabindex="-1"><a class="header-anchor" href="#缓存穿透-雪崩-击穿" aria-hidden="true">#</a> 缓存穿透/雪崩/击穿</h2><p>击穿:单key突然过期，大量请求击穿redis访问Db。 解决:加锁只放行 + 自动刷新 穿透:单key 数据库无数据，不缓存 + 高并发。 解决: 存空值 + 布隆过滤 雪崩:多热点key同时过期 + 高并发. 解决: 过期时间错开 + db限流</p><h2 id="为什么-redis单线程模型效率也能那么高" tabindex="-1"><a class="header-anchor" href="#为什么-redis单线程模型效率也能那么高" aria-hidden="true">#</a> 为什么 Redis单线程模型效率也能那么高</h2><ol><li>C语言实现，效率高</li><li>纯内存操作</li><li>网络模型是基于非阻塞的IO复用模型机制，epoll是Linux提供的最新、最高效的I/O多路复用机制。 redis网络IO模型底层使用IO多路复用，通过reactor模式实现的。 Reactor是一种设计模式，它基于事件驱动。而IO多路复用，是操作系统提供的机制，IO多路复用可以同时监听多个IO事件 Redis6.0 版本之后,Redis 真正拥有了多线程模型（所谓的 I/O threading），这对应了主从Reactor多线程模型的Reactor设计模式。</li></ol><h3 id="redis网络模型" tabindex="-1"><a class="header-anchor" href="#redis网络模型" aria-hidden="true">#</a> redis网络模型</h3><p>redis使用IO多路复用简单来说就是，单线程处理多个客户端连接的网络读写请求，并且能够保证不会阻塞主流程的一种机制 由epoll实现,采用阻塞等待fd(文件描述符),网卡接收到数据时会回调(select,poll实现都需要轮询),优势在于减少非阻塞IO多次系统调用判断是否有数据</p><h2 id="redis高可用架构" tabindex="-1"><a class="header-anchor" href="#redis高可用架构" aria-hidden="true">#</a> Redis高可用架构</h2><p>高可用一般来说有两个含义：一是数据尽量不丢失，二是保证服务尽可能可用 通常有三种部署模式：主从模式(主要是主从复制读写分离)，哨兵模式(解决主从模式主机宕机问题)，集群模式(哨兵模式没有解决master写数据的压力,实现分布式存储，每个节点存储不同的内容)</p>',11),t=[s];function h(c,n){return a(),r("div",null,t)}const l=e(d,[["render",h],["__file","Redis.html.vue"]]);export{l as default};
