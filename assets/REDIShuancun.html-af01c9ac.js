import{_ as e,o as a,c as i,e as r}from"./app-99c01720.js";const d={},s=r('<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> REDIS</h1><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h2><p>查询一个根本不存在的数据，缓存层（比如redis）和持久层（比如mysql数据库）都不会命中。</p><p>若黑客利用此漏洞进行攻击可能<strong>压垮数据库</strong>。</p><p>通常可以在程序中统计总调用数、缓存层命中数、如果同一个Key的缓存命中率很低，可能就是出现了缓存穿透问题。</p><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3><ul><li><p><strong>对空值缓存</strong>：如果一个查询返回的数据为空（不管是数据是否存在），我们仍然把这个空结果（null）进行缓存，并且设置空结果的过期时间会很短，最长不超过五分钟</p></li><li><h4 id="使用布隆过滤器" tabindex="-1"><a class="header-anchor" href="#使用布隆过滤器" aria-hidden="true">#</a> 使用布隆过滤器</h4></li></ul><h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿" aria-hidden="true">#</a> 缓存击穿</h2><p>某热门redis缓存突然过期，同一时间大量高并发请求压垮数据库。来不及回设缓存。</p><h3 id="解决方案-1" tabindex="-1"><a class="header-anchor" href="#解决方案-1" aria-hidden="true">#</a> 解决方案</h3><ul><li><p>预先设置热门数据：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长</p></li><li><p>实时调整：现场监控哪些数据热门，实时调整key的过期时长</p></li><li><p>使用锁（会影响性能）：</p></li><li><p>自动刷新</p></li></ul><p>就是在缓存失效的时候（判断拿出来的值是否为空，如果为空就表示该缓存失效），不是立即去 load db。 先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key（mutex 互斥） 当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key； 当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> 缓存雪崩</h2><p><strong>缓存中数据大批量到过期时间</strong>，大量key出现集中过期，和缓存击穿差不多</p><h3 id="解决方案-2" tabindex="-1"><a class="header-anchor" href="#解决方案-2" aria-hidden="true">#</a> 解决方案</h3><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！解决方案如下：</p><ul><li><strong>构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）</strong></li><li>使用锁或队列：用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。效率低，不适用高并发情况</li><li>设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</li><li>将缓存失效时间分散开：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li><li>限流措施</li></ul><h2 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h2><p><strong>跨机器的互斥机制来控制共享资源的访问</strong>，这就是分布式锁要解决的问题</p><p>分布式锁应该具备哪些条件：</p><p>互斥性：在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 高可用的获取锁与释放锁； 高性能的获取锁与释放锁； 可重入性：具备可重入特性，具备锁失效机制，防止死锁，即就算一个客户端持有锁的期间崩溃而没有主动释放锁，也需要保证后续其他客户端能够加锁成功 非阻塞：具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</p><p>分布式锁的业务场景：</p><ul><li>互联网秒杀（商品库存）</li><li>抢优惠券</li></ul><h3 id="使用-redis-实现分布式锁" tabindex="-1"><a class="header-anchor" href="#使用-redis-实现分布式锁" aria-hidden="true">#</a> 使用 redis 实现分布式锁</h3><p>原理sexnx</p><h3 id="基于redis使用redisson实现分布式锁" tabindex="-1"><a class="header-anchor" href="#基于redis使用redisson实现分布式锁" aria-hidden="true">#</a> 基于redis使用Redisson实现分布式锁</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>',27),n=[s];function h(t,l){return a(),i("div",null,n)}const c=e(d,[["render",h],["__file","REDIShuancun.html.vue"]]);export{c as default};
