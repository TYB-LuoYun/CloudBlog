import{_ as e,o as a,c as r,a as t}from"./app-558ee7ab.js";const i={},d=t('<h1 id="八股文" tabindex="-1"><a class="header-anchor" href="#八股文" aria-hidden="true">#</a> 八股文</h1><h2 id="springmvc" tabindex="-1"><a class="header-anchor" href="#springmvc" aria-hidden="true">#</a> springmvc</h2><p>1.客户端请求提交到前端控制器DispatcherServlet 2.DispatcherServlet接收到请求后、将提交的信息交给处理器映射器(HandlerMapping) 3.HandlerMapping根据用户的url请求、匹配该url的Handler(Controller)，并返回一个执行链 4.DispatcherServlet调用HandlerAdapter(处理器适配器) 5.HandlerAdapter经过适配调用具体的处理器(Controller)扫描 6.Controller扫描完成后返回一个ModelAndView 7.HandlerAdapter将Controller扫描结果(ModelAndView)返回给DispatcherServlet 8.DispatcherServlet将ModelAndView请求试图解析器(ViewReslover)进行解析 9.ViewReslover解析后返回具体的View给前端控制器DispatcherServlet 10.DispatcherServlet将view进行渲染试图(即将模型数据填充到视图中) 11.DispatcherServlet将页面响应给个用户</p><h2 id="拦截器顺序问题" tabindex="-1"><a class="header-anchor" href="#拦截器顺序问题" aria-hidden="true">#</a> 拦截器顺序问题</h2><p>当preHandle方法返回true时，拦截器会按照preHandle -&gt; postHandle -&gt; afterCompletion的顺序执行； 多个拦截器顺序 @Order（int） int数越小，优先级越高</p><h2 id="拦截器过滤器区别" tabindex="-1"><a class="header-anchor" href="#拦截器过滤器区别" aria-hidden="true">#</a> 拦截器过滤器区别</h2><p>过滤器使用filter实现，拦截的是request请求，粒度很大 拦截器基于Java的jdk动态代实现的，实现HandlerInterceptor接口，粒度更小</p><h2 id="拦截器过滤器的原理" tabindex="-1"><a class="header-anchor" href="#拦截器过滤器的原理" aria-hidden="true">#</a> 拦截器过滤器的原理</h2><h2 id="mybatis-plus-与-mybatis区别" tabindex="-1"><a class="header-anchor" href="#mybatis-plus-与-mybatis区别" aria-hidden="true">#</a> mybatis plus 与 mybatis区别</h2><h2 id="mongdb-和-redis-区别" tabindex="-1"><a class="header-anchor" href="#mongdb-和-redis-区别" aria-hidden="true">#</a> mongdb 和 redis 区别</h2><h2 id="aop原理" tabindex="-1"><a class="header-anchor" href="#aop原理" aria-hidden="true">#</a> aop原理</h2><p>Spring AOP的实现基于Java的动态代理技术。当你配置一个Aspect（切面），Spring会为目标对象创建一个代理，这个代理会包含目标对象的方法，以及由Aspect定义的advice（通知）。</p>',12),n=[d];function h(s,l){return a(),r("div",null,n)}const o=e(i,[["render",h],["__file","spring.html.vue"]]);export{o as default};
