import{_ as a,o as e,c as r,e as t}from"./app-d6b918db.js";const h="/assets/image-20240520175500149-0515fe58.png",d="/assets/image-20240520165844336-abcdd93a.png",i={},c=t('<h1 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h1><h1 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h1><h2 id="操作系统的线程" tabindex="-1"><a class="header-anchor" href="#操作系统的线程" aria-hidden="true">#</a> 操作系统的线程</h2><p>5种，创建-&gt;就绪(等待系统调度获得cpu时间片)&lt;-&gt;运行-&gt;(需要等待资源事件)阻塞-&gt;就绪 运行-&gt;终止</p><h2 id="java线程的6种状态" tabindex="-1"><a class="header-anchor" href="#java线程的6种状态" aria-hidden="true">#</a> java线程的6种状态:</h2><p>新建 运行(cpu的就绪+运行):调用了start(),等待倍线程调度选中 阻塞: 线程阻塞于同步锁 等待: 等待其他线程做动作(通知或中断) 超时等待:timed_wating 终止</p><p>thread.sleep 会当前线程进入超时等待状态，不释放对象锁，时间完成后自动进入就绪状态。 作用:给其他线程执行机会的最佳方式</p><p><img src="'+h+'" alt="image-20240520175500149"></p><h1 id="threadlocal" tabindex="-1"><a class="header-anchor" href="#threadlocal" aria-hidden="true">#</a> ThreadLocal</h1><p>ThreadLocal 本地线程变量，ThreadLocal为变量在每个线程中都创建了一个副本，每个线程可以访问自己内部的副本变量，不存在多线程之间的共享问题。 通过源码可以看出，thread内部的ThreadLocalMap对象用entry结构存了所有的线程变量。它的key是个弱引用 弱引用就是每次gc回收，都会回收这个弱引用对象</p><p>如果忘记remove了。那么gc也会因为它是弱引用，主动移除它。 但是value还是占用着内存。我们通常说的内存泄漏，其实都是value的泄漏。</p><p>但是源码已经极大的减少的内存泄漏的可能性。去看源码可以发现，每次set值，remove值或者resize的时候，遍历到这些key=null的entry，都会主动移除里面的value。</p><p><img src="'+d+'" alt="image-20240520165844336"></p><h1 id="inheritablethreadlocal" tabindex="-1"><a class="header-anchor" href="#inheritablethreadlocal" aria-hidden="true">#</a> InheritableThreadLocal</h1><p>InheritableThreadLocal是父子线程可继承的线程变量。它继承了ThreadLocal，重写了几个方法。 使用InheritableThreadLocal可能会有几个问题需要注意。 1父子线程内线程变量的具体value值，是相同的引用。多个线程如果并发修改引用对象内的属性，可能会产生并发问题。 2父子继承存在于new Thread()构造方法中，在父线程进行的copy。如果用了线程池，可能线程是复用的导致传递失败。 使用场景 ：日常项目我们都是通过线程池来使用线程，和InheritableThreadLocal不是很兼容，所以感觉没啥使用场景，一般不用。</p>',15),l=[c];function n(o,s){return e(),r("div",null,l)}const _=a(i,[["render",n],["__file","bingfabao.html.vue"]]);export{_ as default};
